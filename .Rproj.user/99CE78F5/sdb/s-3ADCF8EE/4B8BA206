{
    "contents" : "# LangViz\n# Anupam Panwar\n# Date: September 29, 2016\n\n# server.R\n\n#===============================================================================\n#                               SHINYSERVER                                    #\n#===============================================================================\n\nshinyServer(function(input, output, session) {\n  \n  #===============================================================================\n  #                        DASHBOARD SERVER FUNCTIONS                            #\n  #===============================================================================\n #which language\n  output$usViBox <- renderValueBox({\n    current <- languages[ which(languages$Language == \"java\"), ]\n    valueBox(\n      paste0( current$Language), paste(\" Current Language \"), \n      icon = icon(\"keyboard-o\"), color = \"green\"\n    )\n  })\n  \n  # Number of Users\n  output$highestViBox <- renderValueBox({\n    current <- languages[ which(languages$Language == \"java\"), ]\n    valueBox(\n      paste0(current$Questions), paste(\"Total questions related to this language \"), \n      icon = icon(\"question\"), color = \"blue\"\n    )\n  })\n  \n  # Number of answers\n  output$usAnnualBox <- renderValueBox({\n    current <- languages[ which(languages$Language == \"java\"), ]\n    valueBox(\n      paste0(current$Answers), paste(\"Total answers related to this language \"), icon = icon(\"comments\"), color = \"red\"\n    )\n  })\n  \n  # Render Highest Annual Price Growth  Box\n  output$highestAnnualBox <- renderValueBox({\n    current <- languages[ which(languages$Language == \"java\"), ]\n    valueBox(\n      paste0(current$Users), paste(\"Total users questioned or answered on this language \"), \n      icon = icon(\"\"), color = \"purple\"\n    )\n  })\n  \n  # Render total number of languages\n  output$numStatesBox <- renderValueBox({\n    valueBox(\n      paste0(10), paste(\"Languages\"), \n      icon = icon(\"keyboard-o\"), color = \"green\"\n    )\n  })\n\n  # Render total number of questions\n  output$numCountiesBox <- renderValueBox({\n    valueBox(\n      paste0(1000), paste(\"Questions\"), \n      icon = icon(\"question\"), color = \"yellow\"\n    )\n  })\n\n  # Render total number of answers\n  output$numCitiesBox <- renderValueBox({\n    valueBox(\n      paste0(2500), paste(\"Answers\"), \n      icon = icon(\"comments\"), color = \"red\"\n    )\n  })\n  \n  # Render total number of users\n  output$numZipsBox <- renderValueBox({\n    valueBox(\n      paste0(850), paste(\"Users\"), \n      icon = icon(\"users\"), color = \"yellow\"\n    )\n  })\n  \n  # Render Top 10 tags\n  output$top10tfidf <- renderChart({\n    current <- tfidf\n    cur <- head(arrange(current,desc(tfidf)), n = 10)\n    \n    cur$tfidf <- round(cur$tfidf * 100,2)\n    \n    p <- nPlot(tfidf~keyphrase, data = cur, type = \"discreteBarChart\", dom = \"top10tfidf\")\n    p$params$width <- 1000\n    p$params$height <- 200\n    p$xAxis(staggerLabels = TRUE)\n    p$yAxis(axisLabel = \"TFIDF * 100\", width = 50)\n    return(p)\n  })\n  \n  # Render Top 10 topics\n  output$top10CitiesBar <- renderChart({\n    current <- tfidf\n    cur <- head(arrange(current,desc(tfidf)), n = 10)\n    \n    cur$tfidf <- round(cur$tfidf * 100,2)\n    p <- nPlot(tfidf~keyphrase, data = cur, type = \"discreteBarChart\", dom = \"top10CitiesBar\")\n    p$params$width <- 1000\n    p$params$height <- 200\n    p$xAxis(staggerLabels = TRUE)\n    p$yAxis(axisLabel = \"TFIDF * 100\", width = 50)\n    return(p)\n  })\n  \n  # Render Top 10 States by Home Value Growth TimeSeries\n  output$top10StatesTS <- renderChart({\n    #Get Current Data\n    current <- currentState[ which(currentState$State != \"United States\"), ]\n    current <- arrange(current, desc(Annual))\n    current <- data.frame(current[1:10,3])\n    colnames(current) <- \"State\"\n    \n    #Get Historical Data\n    stateDF <- hviAllState\n    stateDF <- merge(current, stateDF, by = \"State\")\n    stateDF <- subset(stateDF, select = c(State, X2000.01:X2015.12))\n    stateDF <- t(stateDF)\n    colnames(stateDF) <- stateDF[1,]\n    stateDF <- stateDF[-1,]\n    \n    #Format for Plotting \n    timePeriod  <- seq.Date(as.Date('2000/1/1'), by = \"month\", length.out = 192) \n    stateDF <- data.frame(\"Time\" = timePeriod, stateDF)\n    stateDF <- melt(stateDF, id = \"Time\")\n    names(stateDF) <- c(\"Time\", \"State\", \"Value\")\n\n    # Plot Forecast\n    p <- nPlot(Value ~ Time, group = \"State\", type = \"lineChart\", data = stateDF, dom = \"top10StatesTS\", height = 400, width = 680)\n    p$xAxis(\n      tickFormat = \n        \"#!\n      function(d){\n      f =  d3.time.format.utc('%Y-%m-%d');\n      return f(new Date( d*24*60*60*1000 ));\n      }\n      !#\"\n    )\n    p$yAxis(tickFormat = \"#! function(d) {return d3.format(',.0f')(d)} !#\")\n    return(p)\n  })\n  \n  #Render Top 10 Cities by Home Value Growth TimeSeries\n  output$top10CitiesTS <- renderChart({\n    #Get Current Data\n    current <- currentCity\n    current <- arrange(current, desc(Annual))\n    current <- data.frame(current[1:10,])\n    current <- subset(current, select = location)\n    \n    #Get Historical Data\n    cityDF <-  hviAllCity\n    cityDF$location <- paste0(cityDF$City, \", \", cityDF$State)\n    cityDF <- merge(current, cityDF, by = \"location\")\n    cityDF <- subset(cityDF, select = c(location, X2000.01:X2015.12))\n    cityDF <- t(cityDF)\n    colnames(cityDF) <- cityDF[1,]\n    cityDF <- cityDF[-1,]\n    \n    #Format for Plotting \n    timePeriod  <- seq.Date(as.Date('2000/1/1'), by = \"month\", length.out = 192) \n    cityDF <- data.frame(\"Time\" = timePeriod, cityDF)\n    cityDF <- melt(cityDF, id = \"Time\")\n    names(cityDF) <- c(\"Time\", \"City\", \"Value\")\n    \n    # Plot Forecast\n    p <- nPlot(Value ~ Time, group = \"City\", type = \"lineChart\", data = cityDF, dom = \"top10CitiesTS\", height = 400, width = 680)\n    p$xAxis(\n      tickFormat = \n        \"#!\n      function(d){\n      f =  d3.time.format.utc('%Y-%m-%d');\n      return f(new Date( d*24*60*60*1000 ));\n      }\n      !#\"\n    )\n    p$yAxis(tickFormat = \"#! function(d) {return d3.format(',.0f')(d)} !#\")\n    return(p)\n})\n  \n  \n  #===============================================================================\n  #                         MARKET EXPLORER FUNCTIONS                            #\n  #===============================================================================\n  # Level of Analysis UI\n  output$levelQueryUi <- renderUI({\n    radioButtons(\"analysisLevel\", label = \"Level of Analysis\",\n                 choices = list(\"State\" = 1, \"County\" = 2, \"City\" = 3, \"Zip\"  = 4), \n                 selected = 3)\n  })\n  \n  # State query UI\n  output$stateQuery2Ui <- renderUI({\n    states <- sort(unique(geo$StateName))\n    selectInput(\"state2\", label = \"State:\", choices = c(Choose='', as.character(states)), selected = dflt$state, selectize = FALSE)\n  })\n\n  # State query UI\n  output$stateQuery3Ui <- renderUI({\n    states <- sort(unique(geo$StateName))\n    selectInput(\"state3\", label = \"State:\", choices = c(Choose='', as.character(states)), selected = dflt$state, selectize = FALSE)\n  })\n\n  # State query UI\n  output$stateQuery4Ui <- renderUI({\n    states <- sort(unique(geo$StateName))\n    selectInput(\"state4\", label = \"State:\", choices = c(Choose='', as.character(states)), selected = dflt$state, selectize = FALSE)\n  })\n\n  # County Query UI  \n  output$countyQuery3Ui <- renderUI({\n    if (!is.null(input$state3)) {\n      if (input$state3 != \"\") {\n        state <- input$state3\n      } else {\n        state <- dflt$state  \n      }\n    } else {\n      state <- dflt$state\n    }\n    counties <- arrange(unique(subset(geo, StateName == state, select = County)), County)\n    selectInput(\"county3\", label = \"County:\", choices = c(Choose='', as.character(counties$County)), selected = dflt$county, selectize = FALSE)\n  })\n\n  # County Query UI  \n  output$countyQuery4Ui <- renderUI({\n    if (!is.null(input$state4)) {\n      if (input$state4 != \"\") {\n        state <- input$state4\n      } else {\n        state <- dflt$state  \n      }\n    } else {\n      state <- dflt$state\n    }\n    counties <- arrange(unique(subset(geo, StateName == state, select = County)), County)\n    selectInput(\"county4\", label = \"County:\", choices = c(Choose='', as.character(counties$County)), selected = dflt$county, selectize = FALSE)\n  })\n  \n  output$cityQuery4Ui <- renderUI({\n    cities <- NULL\n    \n    if (!is.null(input$state4)) {\n      if (input$state4 != \"\") {\n        if (!is.null(input$county4)) {\n          if (input$county4 != \"\") {\n            cities  <- arrange(unique(subset(geo, StateName == input$state4 & County == input$county4, select = City)), City)\n          } else {\n            cities  <- arrange(unique(subset(geo, StateName == input$state4, select = City)), City)\n          }\n        } else {\n          cities  <- arrange(unique(subset(geo, StateName == input$state4, select = City)), City)\n        }\n      } \n    }  \n    selectInput(\"city4\", label = \"City:\", choices = c(Choose='', as.character(cities$City)), selected = dflt$city, selectize = FALSE)\n  })\n  \n  \n  # Get and screen data based upon home value and growth rates\n  screenData <- function() {\n    # Get Deta\n    d <- switch(input$analysisLevel,\n                  \"1\" = currentState,\n                  \"2\" = currentCounty,\n                  \"3\" = currentCity,\n                  \"4\" = currentZip\n      )\n\n    # Screen based upon home value index\n    minValue <- as.numeric(input$hviQuery[1]) * 1000\n    if (input$maxValue == TRUE) {\n      maxValue <- dflt$maxValue\n    } else {\n      maxValue <- as.numeric(input$hviQuery[2]) * 1000\n    }\n    d <- subset(d, Value >= minValue & Value <= maxValue)\n\n    # Screen based upon growth variable\n    minGrowth <- as.numeric(input$minGrowth) / 100\n    \n    horizon <- input$horizon\n    if (horizon == \"5 Year\") {\n      horizon <- \"Five\"\n    } else if (horizon == \"10 Year\") {\n      horizon <- \"Ten\"\n    }\n    d <- switch(horizon,\n           Monthly = d[ which(d$Monthly >= minGrowth),],\n           Quarterly = d[ which(d$Quarterly >= minGrowth),],\n           Annual = d[ which(d$Annual >= minGrowth),], \n           Five = d[ which(d$Five_Year >= minGrowth),],\n           Ten = d[ which(d$Ten_Year >= minGrowth),])\n    \n     return(d)\n  }\n  \n\n  # Get Data for State level of analysis\n  getStateData <- function() {\n    \n    # Get data screened by value and growth rates\n    d <- screenData()\n    \n    # Format growth record\n    horizon <- input$horizon\n    if (horizon == \"5 Year\") {\n      horizon <- \"Five\"\n    } else if (horizon == \"10 Year\") {\n      horizon <- \"Ten\"\n    }\n    d <- switch(horizon,\n                Monthly   = select(d, State, Value, Monthly, location),\n                Quarterly = select(d, State, Value, Quarterly, location),\n                Annual    = select(d, State, Value, Annual, location),\n                Five      = select(d, State, Value, Five_Year, location),\n                Ten       = select(d, State, Value, Ten_Year, location))\n\n    return(d)\n                \n  }\n  \n  \n  # Get Data for County level of analysis\n  getCountyData <- function() {\n    # Get data screened by value and growth rates\n    d <- screenData()\n    \n    # Filter based upon state \n    if (!is.null(input$state2) & (input$state2 != \"\")) {\n      d <- d[ which(d$StateName == input$state2),]\n    } \n    \n    # Format growth record\n    horizon <- input$horizon\n    if (horizon == \"5 Year\") {\n      horizon <- \"Five\"\n    } else if (horizon == \"10 Year\") {\n      horizon <- \"Ten\"\n    }\n    d <- switch(horizon,\n                Monthly   = select(d, StateName, County, Value, Monthly, location),\n                Quarterly = select(d, StateName, County, Value, Quarterly, location),\n                Annual    = select(d, StateName, County, Value, Annual, location),\n                Five      = select(d, StateName, County, Value, Five_Year, location),\n                Ten       = select(d, StateName, County, Value, Ten_Year))    \n    return(d)\n    \n  }\n  \n  \n  \n  # Get Data for City level of analysis\n  getCityData <- function() {\n    \n    # Get data screened by value and growth rates\n    d <- screenData()\n    \n    # Filter based upon state and county entered\n    if (!is.null(input$county3) & (input$county3 != \"\")) {\n      d <- d[ which(d$County == input$county3),]\n    } else if (!is.null(input$state3) & (input$state3 != \"\")) {\n      d <- d[ which(d$StateName == input$state3),]\n    } \n    \n    # Format growth record\n    horizon <- input$horizon\n    if (horizon == \"5 Year\") {\n      horizon <- \"Five\"\n    } else if (horizon == \"10 Year\") {\n      horizon <- \"Ten\"\n    }\n    d <- switch(horizon,\n                Monthly = select(d, StateName, County, City, Value, Monthly, location),\n                Quarterly = select(d, StateName, County, City, Value, Quarterly, location),\n                Annual = select(d, StateName, County, City, Value, Annual, location),\n                Five = select(d, StateName, County, City, Value, Five_Year, location),\n                Ten = select(d, StateName, County, City, Value, Ten_Year, location))       \n    return(d)\n    \n  }\n  \n  \n  \n  # Get Data for Zip level of analysis\n  getZipData <- function() {\n    # Get data screened by value and growth rates\n    d <- screenData()\n\n    # Filter based upon state\n    if (!is.null(input$state4)) {\n      if (input$state4 != \"\") {\n        d <- d[ which(d$StateName == input$state4),]\n      }\n    }\n        \n    # Filter based upon county\n    if (!is.null(input$county4)) {\n      if (input$county4 != \"\") {\n        d <- d[ which(d$County == input$county4 & d$StateName == input$state4),]\n      }\n    }\n    # Filter based upon state and county entered\n    if (!is.null(input$city4)) {\n      if (input$city4 != \"\") {\n        d <- d[ which(d$City == input$city4 & d$StateName == input$state4),]\n      }\n    }\n    \n    # Format growth record\n    horizon <- input$horizon\n    if (horizon == \"5 Year\") {\n      horizon <- \"Five\"\n    } else if (horizon == \"10 Year\") {\n      horizon <- \"Ten\"\n    }\n    d <- switch(horizon,\n                Monthly = select(d, StateName, County, City, Zip, Value, Monthly, location),\n                Quarterly = select(d, StateName, County, City, Zip, Value, Quarterly, location),\n                Annual = select(d, StateName, County, City, Zip, Value, Annual, location),\n                Five = select(d, StateName, County, City, Zip, Value, Five_Year, location),\n                Ten = select(d, StateName, County, City, Zip, Value, Ten_Year, location))           \n    \n    return(d)\n    \n  }\n  \n  \n  \n  # Retrieves Data for Value Presentation\n  getData <- eventReactive(input$query, {\n    \n    d <- switch(input$analysisLevel,\n                \"1\" = getStateData(),\n                \"2\" = getCountyData(),\n                \"3\" = getCityData(),\n                \"4\" = getZipData()\n                )\n\n    validate(\n      need(nrow(d)>0, \"No markets meet your search criteria.  Please select adjust home value range, minimum growth rate, and/or the geographic filter.\")\n    )\n    \n      return(d)\n  }, ignoreNULL = FALSE)\n\n\n  # Get Growth Data\n  getGrowthData <- eventReactive(input$query, {\n    \n    d <- getData()\n    \n    # Configure Chart based upon input horizon\n    horizon <- input$horizon\n    if (horizon == \"5 Year\") {\n      horizon <- \"Five\"\n    } else if (horizon == \"10 Year\") {\n      horizon <- \"Ten\"\n    }\n    \n    # Sort by horizon\n    if (nrow(d) != 0) {\n      d <- switch(horizon,\n                  Monthly = arrange(d, desc(Monthly)),\n                  Quarterly = arrange(d, desc(Quarterly)),\n                  Annual = arrange(d, desc(Annual)),\n                  Five = arrange(d, desc(Five_Year)),\n                  Ten = arrange(d, desc(Ten_Year)))\n    } \n    \n    \n  }, ignoreNULL = FALSE)\n  \n  \n  # Merge current and historical data for number of markets requested.\n  mergeMarketData <- function(d,n) {\n\n    #if state level of analysis, remove row for USA from data frame.\n    if (input$analysisLevel == 1) {\n      d <- d[ which(d$State != \"United States\"), ]\n    }\n    \n    #Subset current data to top n markets by growth\n    if (!is.null(d)) {\n      numMarkets <- n\n      if (nrow(d) < numMarkets) {\n        numMarkets <- nrow(d)\n      }\n      d <- d[1:numMarkets,]\n    }\n    \n    #Get historical pricing data based upon level of analysis\n    h <- switch (isolate(input$analysisLevel),\n                 \"1\" = hviAllState,\n                 \"2\" = hviAllCounty,\n                 \"3\" = hviAllCity,\n                 \"4\" = hviAllZip\n    )\n    \n    m <- merge(d, h, by = \"location\")\n\n    return(m)\n  }\n\n  output$valueByGrowth <- renderPlotly({\n    \n    withProgress(message = \"Rendering Value By Growth Plot\", {\n                 \n      # Get Data\n      d <- getGrowthData()\n      \n      # Subset into top results\n      if (!is.null(d)) {\n        numBars <- 1000\n        if (nrow(d) < numBars) {\n          numBars <- nrow(d)\n        }\n        d <- d[1:numBars,]\n      }\n      \n      # Prepare data based upon input horizon\n      horizon <- isolate(input$horizon)\n      if (horizon == \"5 Year\") {\n        horizon <- \"Five\"\n      } else if (horizon == \"10 Year\") {\n        horizon <- \"Ten\"\n      }\n      \n      d <- switch(horizon,\n                  Monthly = subset(d, select = c(location, Value, Monthly)),\n                  Quarterly = subset(d, select = c(location, Value, Quarterly)),  \n                  Annual = subset(d, select = c(location, Value, Annual)),            \n                  Five = subset(d, select = c(location, Value, Five_Year)),            \n                  Ten = subset(d, select = c(location, Value, Ten_Year))\n      )\n      colnames(d) <- c(\"Location\", \"Value\", \"Growth\")\n      \n      # Convert Growth Rate to Percentage\n      d$Growth = as.numeric(d$Growth) * 100\n      \n      # Designate axis labels\n      x <- list(title = \"Median Home Value\")\n      y <- list(title = \"Percent Value Growth\")\n      \n      # Prepare plot\n      p <- plot_ly(d, x = Value, y = Growth, text = Location, mode = \"markers\", color = Value, size = Value) %>%\n        layout(xaxis = x, yaxis = y)\n    })\n  })\n  \n  #Render Top Markets by Growth\n  output$topByGrowth <- renderChart({\n    \n    withProgress(message = \"Rendering Top Markets by Growth Plot\", {\n      # Get Data\n      d <- getGrowthData()\n      \n      # Subset into top results\n      if (!is.null(d)) {\n        numBars <- 10\n        if (nrow(d) < numBars) {\n          numBars <- nrow(d)\n        }\n        d <- d[1:numBars,]\n      }\n      \n      # Prepare data based upon input horizon\n      horizon <- isolate(input$horizon)\n      if (horizon == \"5 Year\") {\n        horizon <- \"Five\"\n      } else if (horizon == \"10 Year\") {\n        horizon <- \"Ten\"\n      }\n  \n      d <- switch(horizon,\n                  Monthly = subset(d, select = c(location, Monthly)),\n                  Quarterly = subset(d, select = c(location, Quarterly)),            \n                  Annual = subset(d, select = c(location, Annual)),            \n                  Five = subset(d, select = c(location, Five_Year)),            \n                  Ten = subset(d, select = c(location, Ten_Year))\n      )\n      colnames(d) <- c(\"location\", \"Growth\")\n      d$Growth <- as.numeric(d$Growth) * 100\n      \n      #Prepare plot\n      p <- nPlot(Growth~location, data = d)\n      p$addParams(dom = \"topByGrowth\", type = \"discreteBarChart\")\n      p$set(width = 1200, height = 300)\n      p$xAxis(staggerLabels = TRUE)\n      p$yAxis(axisLabel = \"Growth Rate (%)\", width = 50)\n      return(p)\n    })\n  })\n  \n\n  # Render Market Data Table\n  output$marketTbl <- renderDataTable({\n    \n    withProgress(message = \"Rendering Market Table\", {\n      d <- getGrowthData()\n    })\n    \n    #Drop location variable\n    d$location <- NULL \n    return(d)\n  }, options = list(lengthMenu = c(5, 30, 50), autowidth = TRUE, pageLength = 5))\n  \n\n  output$valueHist <- renderPlot({\n    withProgress(message = \"Rendering Value Histogram\", {\n      \n      # Get Data\n      d <- getData()\n  \n      # Render error message if not enough data to produce histogram\n      validate(\n        need(nrow(d) > 1, \"Not enough data to produce histogram.\")\n      )\n      \n      # Subset Data\n      d <- subset(d, select = c(\"location\", \"Value\"))\n      \n      # Convert Value to ($000)\n      d$Value <- as.numeric(d$Value) / 1000\n      \n      #Set Parameters\n      bins <- seq(min(d$Value), max(d$Value), length.out = 31)\n      \n      #Draw Histogram\n      hist(as.numeric(d$Value), breaks = bins, col = \"skyblue\", border = \"white\",\n           xlab = \"Median Home Values ($000)\", \n           main = \"Histogram of Median Home Values\")\n    })\n  })\n  \n\n  #Render Top Markets by Home Value Growth TimeSeries\n  output$topMarketsTS <- renderChart({\n    \n    withProgress(message = \"Rendering Top Market Time Series\", {\n      \n      # Get Data\n      d <- getGrowthData()\n      \n      # Set number of markets to plot.  Markets are sorted by Growth (desc)\n      numMarkets <- 10\n      \n      # Merge current with historical data for number of markets\n      d <- mergeMarketData(d, numMarkets)\n  \n      # Format for Plotting\n      d <- subset(d, select = c(location, X2000.01:X2015.12))\n      d <- t(d)\n      colnames(d) <- d[1,]\n      d <- d[-1,]\n      timePeriod  <- seq.Date(as.Date('2000/1/1'), by = \"month\", length.out = 192)\n      d <- data.frame(\"Time\" = timePeriod, d)\n      ts <- melt(d, id = \"Time\")\n      names(ts) <- c(\"Time\", \"Market\", \"Value\")\n  \n      #Plot Data\n      p <- nPlot(Value ~ Time, group = \"Market\", type = \"lineChart\", data = ts, width = 1100, height = 600, dom = \"topMarketsTS\")\n      p$xAxis(\n        tickFormat = \n          \"#!\n        function(d){\n        f =  d3.time.format.utc('%Y-%m-%d');\n        return f(new Date( d*24*60*60*1000 ));\n        }\n        !#\"\n      )\n      p$yAxis(tickFormat = \"#! function(d) {return d3.format(',.0f')(d)} !#\")\n      return(p)\n    })\n  })\n  \n  #===============================================================================\n  #                        MARKET SELECTOR FUNCTIONS                             #\n  #===============================================================================\n  \n  # State query UI\n  output$stateUi <- renderUI({\n    states <- sort(unique(geo$StateName))\n    selectInput(\"state\", label = \"State:\", choices = c(Choose='', as.character(states)), selected = dflt$state, selectize = FALSE)\n  })\n  \n  # County Query UI  \n  output$countyUi <- renderUI({\n    counties <- NULL\n    if (!is.null(input$state)) {\n      counties <- unique(subset(geo, StateName == input$state, select = County))\n      counties <- sort(counties$County)\n    }\n    selectInput(\"county\", label = \"County:\", choices = c(Choose='', as.character(counties)), selected = dflt$county, selectize = FALSE)\n  })\n  \n  # Render City Query ui\n  output$cityUi <- renderUI({\n    cities <- NULL\n    \n    if (!is.null(input$state)) {\n      if (input$state != \"\") {\n        if (!is.null(input$county)) {\n          if (input$county != \"\") {\n            cities  <- unique(subset(geo, StateName == input$state & County == input$county, select = City))\n          } else {\n            cities  <- unique(subset(geo, StateName == input$state, select = City))\n          }\n        } else {\n          cities  <- unique(subset(geo, StateName == input$state, select = City))\n        }\n      } \n    }\n    \n    cities <- sort(cities$City)\n    selectInput(\"city\", label = \"City:\", choices = c(Choose='', as.character(cities)), selected = dflt$city, selectize = FALSE)\n  })\n  \n  # Render Zip Query UI \n  output$zipUi <- renderUI({\n    zips <- NULL\n    \n    if (!is.null(input$state)) {\n      if (input$state != \"\") {\n        zips <- unique(subset(geo, StateName == input$state))\n      }\n    }\n    \n    if (!is.null(input$county)) {\n      if (input$county != \"\") {\n        zips <- unique(subset(zips, StateName == input$state & County == input$county))\n      }\n    }\n    \n    if (!is.null(input$city)) {\n      if (input$city != \"\") {\n        zips <- unique(subset(zips, StateName == input$state & City == input$city))\n      }\n    }\n    \n    zips <- sort(zips$Zip)\n    \n    selectInput(\"zip\", label = \"Zip:\", choices = c(Choose='', as.character(zips)), selected = dflt$zip, selectize = FALSE)\n    \n  })\n  \n  # Determine level of market selected.\n  getLevel <- reactive({\n    \n    #Initialize Level\n    level <- \"0\"\n    \n    # Get State Data \n    if (!is.null(input$state)) {\n      if (input$state != \"\") {\n        level <- \"1\"\n      }\n    }\n    \n    if (!is.null(input$county)) {\n      if (input$county != \"\") {\n        level <- \"2\"\n      }\n    } \n    \n    if (!is.null(input$city)) {\n      if (input$city != \"\") {\n        level <- \"3\"\n      }\n    } \n    \n    if (!is.null(input$zip)) {\n      if (input$zip != \"\") {\n        level <- \"4\"\n      }\n    } \n    \n    return(level)\n  })\n  \n  # Get Current Data\n  selectCurrentData <- reactive({\n    level <- getLevel()\n    \n    d <- switch(level,\n                \"1\" = subset(currentState, State == input$state),\n                \"2\" = subset(currentCounty, StateName == input$state & County == input$county),\n                \"3\" = subset(currentCity, StateName == input$state & City == input$city),\n                \"4\" = subset(currentZip, Zip == input$zip)\n                )\n  })\n\n  # Get Historical Data\n  selectHistoricalData <- reactive({\n    level <- getLevel()\n\n    d <- switch(level,\n                \"1\" = subset(hviAllState, State == input$state, select = X2000.01:X2015.12),\n                \"2\" = subset(hviAllCounty, StateName == input$state & County == input$county, select = X2000.01:X2015.12),\n                \"3\" = subset(hviAllCity, StateName == input$state & City == input$city, select = X2000.01:X2015.12),\n                \"4\" = subset(hviAllZip, Zip == input$zip, select = X2000.01:X2016.01)\n                )\n    \n    validate(\n      need(!is.null(d), \"There are no data to analyze. Please select a market and press 'Go' to process the analysis.\")\n    )\n    \n    validate(\n      need(!(nrow(d) == 0), \"There are no data to analyze. Please select another market and press 'Go' to process the analysis.\")\n    )\n\n    validate(\n      need(!any(is.na(d)), \"Unable to produce a timeseries with NA values. Please select a different market in the sidebar. \")\n    )\n    \n    return(d)\n  })\n\n  #===============================================================================\n  #                         VALUE ANALYSIS FUNCTIONS                             #\n  #===============================================================================\n  \n  #Render Home Value Index Box for selected market\n  output$hviBox <- renderValueBox({\n    \n    input$analyze\n    \n    d <- isolate(selectCurrentData())\n    \n    validate(\n      need(!is.null(d),\"\")\n    )\n    \n    valueBox(\n      paste0(\"$\", d$Value), paste(d$location, \" Median Home Value \"), \n      icon = icon(\"dollar\"), color = \"green\"\n    )\n  })\n  \n  #Render Five Year Growth Box for selected market\n  output$annualBox <- renderValueBox({\n    \n    input$analyze\n    \n    d <- isolate(selectCurrentData())    \n    \n    validate(\n      need(!is.null(d), \"\")\n    )\n    \n    valueBox(\n      paste0(round(d$Annual * 100,4), \"%\"), paste(d$location,\n        \" Annual Change in Home Values\"), icon = icon(\"bar-chart\"), color = \"red\"    )\n  })\n  \n  #Render Annual Growth Box for selected market\n  output$fiveYearBox <- renderValueBox({\n\n    input$analyze\n    \n    d <- isolate(selectCurrentData())\n    \n    validate(\n      need(!is.null(d), \"\")\n    )\n    valueBox(\n      paste0(round(d$Five_Year * 100,4), \"%\"), paste(d$location,\n      \" Five Year Change in Home Values\"), icon = icon(\"bar-chart\"), color = \"orange\"    )\n  })\n  \n  #Render Annual Growth Box for selected market\n  output$tenYearBox <- renderValueBox({\n    \n    input$analyze\n    \n    d <- isolate(selectCurrentData())\n    \n    validate(\n      need(!is.null(d), \"\")\n    )\n    \n    valueBox(\n      paste0(round(d$Ten_Year * 100,4), \"%\"), paste(d$location,\n      \" Ten Year Change in Home Values\"), icon = icon(\"bar-chart\"), color = \"blue\"    )\n  })\n  \n  #Gets time series for a selected market.\n  getTimeSeries <- eventReactive(input$analyze, {\n    d <- selectHistoricalData()\n    \n    d <- as.numeric(as.vector(d))\n    timeSeries <- ts(d, frequency = 12, start = c(2000,1))\n    return(timeSeries)\n\n  }, ignoreNULL = FALSE)\n  \n  \n  \n  # Render non-seasonal trend time series\n  output$nsPlot <- renderPlot({\n    Price <- SMA(getTimeSeries(), n = input$span)\n    autoplot(Price, ts.colour = \"blue\") + theme_bw()\n  })\n  \n  # Render seasonal time series decomposition\n  output$tsiPlot <- renderPlot({\n    Price <- decompose(getTimeSeries())\n    autoplot(Price, ts.colour = \"blue\") + theme_bw()\n  })\n  \n  #===============================================================================\n  ##              FORECAST MODEL TRAINING FUNCTIONS                              #\n  #===============================================================================\n\n  # Render model select\n  output$modelsUi <- renderUI({\n    selectInput(\"model\", label = \"Prediction Models:\", choices = c(Choose='',as.character(modelData$code)), selected = dflt$model, selectize = FALSE)\n  })\n  \n  # Render model name\n  output$modelNameUi <- renderText({\n    if (is.null(input$model)) {\n      m <- dflt$model\n    } else {\n      m <- input$model\n    }\n    paste(modelData[ which(modelData$code == m), ]$name)\n  })\n  \n  # Render model description\n  output$modelDescUi <- renderText({\n    if (is.null(input$model)) {\n      m <- dflt$model\n    } else {\n      m <- input$model\n    }\n    paste(modelData[ which(modelData$code == m), ]$desc)  \n  })\n  \n  \n  # Split data into training and test/validation set\n  splitData <- function() {\n    \n    if (is.null(input$split)) {\n      y <- dflt$split\n    } else {\n      y <- as.numeric(input$split)\n    }\n    \n    validate(\n      need(input$state != \"\", \"Please select a market using the geographic selectors in the sidebar. \")\n    )\n    \n    d <- selectHistoricalData()\n\n    # Create time series object on full data\n    marketPrices  <- as.numeric(as.vector(d))\n    tSeries       <- ts(marketPrices, frequency = 12, start = c(2000,1))\n    \n    #Split into training and test set\n    tsTest  <- window(tSeries, start = c(y+1,1))\n    tsTrain <- window(tSeries, end = c(y,12))\n    \n    #Combine into a list\n    l <- list(\"train\" = tsTrain, \"test\" = tsTest)\n    return(l)\n  }\n  \n\n  # Get plot options, specifically, number of periods to forecast and to include\n  getForecastOptions <- function() {\n \n    # Determine number of periods to forecast\n    if (is.null(input$split) || input$split == \"\") {\n      periods <- 12\n    } else {\n      periods <- (2015 - as.integer(input$split)) * 12\n    }\n    \n    # Determine number of back periods to include\n    if ((periods * 3) > (192 - periods)) {\n      include <- 192 - periods\n    } else {\n      include <- periods * 3\n    }\n    \n    # Determine ylimit at peak price\n    maximum <- as.integer(max(selectHistoricalData()))\n    \n    #Combine into a list and return\n    l <- list(periods = periods, include = include, maximum = maximum)\n    \n  }\n  \n  \n  # Prepare predictions\n  trainModel <- function(model, data) {\n    m <- model()\n    d <- data()\n\n    msg <- paste(\"Training \", m, \" algorithm\")\n\n    validate(\n      need(!any(is.na(d)), \"There are NA values in the training set for this market. Please change your selection criteria in Market Selector\")\n    )\n    \n    withProgress(message = msg,\n      if (!is.null(d)) {\n        switch (m,\n                ARIMA = auto.arima(d, ic='aicc', stepwise=FALSE),\n                ETS = ets(d, ic='aicc', restrict=FALSE),\n                NEURAL = nnetar(d, p=12, size=25),\n                TBATS = tbats(d, ic='aicc', seasonal.periods=12),\n                BATS = bats(d, ic='aicc', seasonal.periods=12),\n                STLM = stlm(d, s.window=12, ic='aicc', robust=TRUE, method='ets'),\n                STS = StructTS(d, type = \"level\"),\n                NAIVE = naive(d, 12)\n      )\n    }\n  )}\n  \n  \n  #Format Accuracy Results into a table\n  formatAccuracy <- function(r) {\n    \n    if (!is.null(r)) {\n      measure    <-c(\"Mean Error (ME)\",\n                     \"Root Mean Squared Error (RMSE)\",\n                     \"Mean Absolute Error (MAE)\",\n                     \"Mean Percentage Error (MPE)\",\n                     \"Mean Absolute Percentage Error (MAPE)\",\n                     \"Mean Absolute Scaled Error (MASE)\",\n                     \"Autocorrelation of errors at lag 1. (ACF1)\",\n                     \"ThEIl's U\")\n      trainingSet <- round(r[,1], 3)\n      testSet     <- round(r[,2], 3)\n      results     <- data.frame(measure, trainingSet, testSet)\n      names(results) <- c(\"Measure\", \"Training Set\", \"Test Set\")\n      return(results)\n    }\n  }\n  \n  # Get training forecast and test data for single plot on train page\n  getSinglePlotData <- eventReactive(input$train, {\n    \n    d <- splitData()\n    m <- trainModel(reactive(input$model), reactive(d$train))\n    o <- getForecastOptions()\n    p <- forecast(m, o$periods)\n    a <- accuracy(p, d$test)\n    r <- t(a)\n    ma <- formatAccuracy(r)\n    \n    #Combine into a list\n    l <- list(\"train\" = d$train, \"test\" = d$test, \"model\" = m$model, \n              \"periods\" = o$periods, \"maximum\" = o$maximum, \"include\" = o$include,\n              \"prediction\" = p, \"results\" = r, \"accuracy\" = ma)\n    \n    #Return list\n    return(l)\n  }, ignoreNULL = FALSE)\n  \n  \n  # Render training forecast plot\n  output$modelPlot <- renderPlot({\n    \n    p <- getSinglePlotData()\n    plot(p$prediction, include = p$include, ylim=c(0,as.numeric(p$maximum)))\n    lines(p$test, col = \"red\")\n    legend(\"bottomright\",\n           inset=.05,\n           cex = 1,\n           title=\"Legend\",\n           c(\"Actual Values\",\"Predicted Values\"),\n           horiz=FALSE,\n           lty=c(1,1),\n           lwd=c(2,2),\n           col=c(\"red\",\"blue\"),\n           bg=\"white\",\n           text.font=3)\n  })\n  \n  output$accuracy <- renderDataTable({\n    a <- getSinglePlotData()\n    a$accuracy\n  })\n  \n  #===============================================================================\n  #                         MODEL COMPARISON FUNCTIONS                           #\n  #===============================================================================\n  #Render Home Value Index Box for selected market\n  output$hviBox2 <- renderValueBox({\n    \n    input$compare\n    \n    d <- isolate(selectCurrentData())\n    \n    validate(\n      need(!is.null(d),\"\")\n    )\n    \n    valueBox(\n      paste0(\"$\", d$Value), paste(d$location, \" Median Home Value \"), \n      icon = icon(\"dollar\"), color = \"green\"\n    )\n  })\n  \n  #Render Five Year Growth Box for selected market\n  output$annualBox2 <- renderValueBox({\n    \n    input$compare\n    \n    d <- isolate(selectCurrentData())\n    \n    validate(\n      need(!is.null(d), \"\")\n    )\n    \n    valueBox(\n      paste0(round(d$Annual * 100,4), \"%\"), paste(d$location,\n                                                  \" Annual Change in Home Values\"), icon = icon(\"bar-chart\"), color = \"red\"    )\n  })\n  \n  #Render Annual Growth Box for selected market\n  output$fiveYearBox2 <- renderValueBox({\n    \n    input$compare\n    \n    d <- isolate(selectCurrentData())\n    \n    validate(\n      need(!is.null(d), \"\")\n    )\n    valueBox(\n      paste0(round(d$Five_Year * 100,4), \"%\"), paste(d$location,\n                                                     \" Five Year Change in Home Values\"), icon = icon(\"bar-chart\"), color = \"orange\"    )\n  })\n  \n  #Render Annual Growth Box for selected market\n  output$tenYearBox2 <- renderValueBox({\n\n    input$compare\n    \n    d <- isolate(selectCurrentData())\n    \n    validate(\n      need(!is.null(d), \"\")\n    )\n    \n    valueBox(\n      paste0(round(d$Ten_Year * 100,4), \"%\"), paste(d$location,\n                                                  \" Ten Year Change in Home Values\"), icon = icon(\"bar-chart\"), color = \"blue\"    )\n  })\n\n\n  # Get Arima Plot Data\n  getArimaPlotData <- eventReactive(input$compare, {\n\n    d <- splitData()\n    m <- auto.arima(d$train, ic='aicc', stepwise=FALSE)\n    o <- getForecastOptions()\n    p <- forecast(m, o$periods)\n    a <- accuracy(p, d$test)\n    accuracyArima <- t(a)\n    \n    #Combine into a list\n    p <- list(\"train\" = d$train, \"test\" = d$test, \"model\" = m$model, \n              \"periods\" = o$periods, \"maximum\" = o$maximum, \"include\" = o$include,\n              \"prediction\" = p, \"results\" = accuracyArima)\n    \n    #Return list\n    return(p)\n  }, ignoreNULL = FALSE)\n  \n\n  # Get ETS Plot Data\n  getEtsPlotData <- eventReactive(input$compare, {\n    \n    d <- splitData()\n    m <- ets(d$train, ic='aicc', restrict=FALSE)\n    o <- getForecastOptions()\n    p <- forecast(m, o$periods)\n    a <- accuracy(p, d$test)\n    accuracyEts <- t(a)\n    \n    #Combine into a list\n    p <- list(\"train\" = d$train, \"test\" = d$test, \"model\" = m$model, \n              \"periods\" = o$periods, \"maximum\" = o$maximum, \"include\" = o$include,\n              \"prediction\" = p, \"results\" = accuracyEts)\n    \n    #Return list\n    return(p)\n  }, ignoreNULL = FALSE)\n  \n\n  # Get Naive Plot Data\n  getNaivePlotData <- eventReactive(input$compare, {\n    \n    d <- splitData()\n    m <- naive(d$train, getForecastOptions()$periods)\n    o <- getForecastOptions()\n    p <- forecast(m, o$periods)\n    a <- accuracy(p, d$test)\n    accuracyNaive <- t(a)\n    \n    #Combine into a list\n    p <- list(\"train\" = d$train, \"test\" = d$test, \"model\" = m$model, \n              \"periods\" = o$periods, \"maximum\" = o$maximum, \"include\" = o$include,\n              \"prediction\" = p, \"results\" = accuracyNaive)\n    \n    #Return list\n    return(p)\n  }, ignoreNULL = FALSE)\n  \n  \n  # Get Neural Plot Data\n  getNeuralPlotData <- eventReactive(input$compare, {\n    \n    d <- splitData()\n    m <- nnetar(d$train, p=12, size=25)\n    o <- getForecastOptions()\n    p <- forecast(m, o$periods)\n    a <- accuracy(p, d$test)\n    accuracyNeural <- t(a)\n    \n    #Combine into a list\n    p <- list(\"train\" = d$train, \"test\" = d$test, \"model\" = m$model, \n              \"periods\" = o$periods, \"maximum\" = o$maximum, \"include\" = o$include,\n              \"prediction\" = p, \"results\" = accuracyNeural)\n    \n    #Return list\n    return(p)\n  }, ignoreNULL = FALSE)\n  \n  \n  # Get BATS Plot Data\n  getBATSPlotData <- eventReactive(input$compare, {\n    \n    d <- splitData()\n    m <- bats(d$train, ic='aicc', seasonal.periods=12)\n    o <- getForecastOptions()\n    p <- forecast(m, o$periods)\n    a <- accuracy(p, d$test)\n    accuracyBats <- t(a)\n    \n    #Combine into a list\n    p <- list(\"train\" = d$train, \"test\" = d$test, \"model\" = m$model, \n              \"periods\" = o$periods, \"maximum\" = o$maximum, \"include\" = o$include,\n              \"prediction\" = p, \"results\" = accuracyBats)\n    \n    #Return list\n    return(p)\n  }, ignoreNULL = FALSE)\n  \n  \n  # Get TBATS Plot Data\n  getTBATSPlotData <- eventReactive(input$compare, {\n    \n    d <- splitData()\n    m <- tbats(d$train, ic='aicc', seasonal.periods=12)\n    o <- getForecastOptions()\n    p <- forecast(m, o$periods)\n    a <- accuracy(p, d$test)\n    accuracyTbats <- t(a)\n    \n    #Combine into a list\n    p <- list(\"train\" = d$train, \"test\" = d$test, \"model\" = m$model, \n              \"periods\" = o$periods, \"maximum\" = o$maximum, \"include\" = o$include,\n              \"prediction\" = p, \"results\" = accuracyTbats)\n    \n    #Return list\n    return(p)\n  }, ignoreNULL = FALSE)\n  \n  # Get STLM Plot Data\n  getSTLMPlotData <- eventReactive(input$compare, {\n    \n    d <- splitData()\n    m <- stlm(d$train, s.window=12, ic='aicc', robust=TRUE, method='ets')\n    o <- getForecastOptions()\n    p <- forecast(m, o$periods)\n    a <- accuracy(p, d$test)\n    accuracyStlm <- t(a)\n    \n    #Combine into a list\n    p <- list(\"train\" = d$train, \"test\" = d$test, \"model\" = m$model, \n              \"periods\" = o$periods, \"maximum\" = o$maximum, \"include\" = o$include,\n              \"prediction\" = p, \"results\" = accuracyStlm)\n    \n    #Return list\n    return(p)\n  }, ignoreNULL = FALSE)\n  \n  # Get STS Plot Data\n  getSTSPlotData <- eventReactive(input$compare, {\n    \n    d <- splitData()\n    m <- StructTS(d$train, type = \"level\")\n    o <- getForecastOptions()\n    p <- forecast(m, o$periods)\n    a <- accuracy(p, d$test)\n    accuracySts <- t(a)\n  \n    #Combine into a list\n    p <- list(\"train\" = d$train, \"test\" = d$test, \"model\" = m$model, \n              \"periods\" = o$periods, \"maximum\" = o$maximum, \"include\" = o$include,\n              \"prediction\" = p, \"results\" = accuracySts)    \n    \n    #Return list\n    return(p)\n  }, ignoreNULL = FALSE)\n  \n  #Summarize performance error statistics \n  errorStats <- eventReactive(input$compare, {\n    \n    accuracyTbl <- NULL\n    \n    validate(\n      need(input$state != \"\", \"Please select a market using the geographic selectors in the sidebar. \")\n    )\n    \n    accuracyArima  <-\tisolate(getArimaPlotData())\n    accuracyEts\t   <-\tisolate(getEtsPlotData())\n    accuracyNaive\t <-\tisolate(getNaivePlotData())\n    accuracyNeural <-\tisolate(getNeuralPlotData())\n    accuracyBats\t <-\tisolate(getBATSPlotData())\n    accuracyTbats\t <-\tisolate(getTBATSPlotData())\n    accuracyStlm\t <-\tisolate(getSTLMPlotData())\n    accuracySts\t   <-\tisolate(getSTSPlotData())\n    \n    `%then%` <- shiny:::`%OR%`\n    \n    validate(\n      need(accuracyArima  != \"\", \"Unable to prepare performance metrics with this data.  Please select a different market in the sidebar.\")  %then%\n      need(accuracyEts    != \"\", \"Unable to prepare performance metrics with this data.  Please select a different market in the sidebar.\")  %then%\n      need(accuracyNaive  != \"\", \"Unable to prepare performance metrics with this data.  Please select a different market in the sidebar.\")  %then%\n      need(accuracyNeural != \"\", \"Unable to prepare performance metrics with this data.  Please select a different market in the sidebar.\")  %then%\n      need(accuracyBats   != \"\", \"Unable to prepare performance metrics with this data.  Please select a different market in the sidebar.\")  %then%\n      need(accuracyTbats  != \"\", \"Unable to prepare performance metrics with this data.  Please select a different market in the sidebar.\")  %then%\n      need(accuracyStlm   != \"\", \"Unable to prepare performance metrics with this data.  Please select a different market in the sidebar.\")  %then%\n      need(accuracySts    != \"\", \"Unable to prepare performance metrics with this data.  Please select a different market in the sidebar.\")  %then%\n      need(accuracySts    != \"\", \"Unable to prepare performance metrics with this data.  Please select a different market in the sidebar.\")\n    )\n    \n    accuracyTbl <-  as.data.frame(rbind(round(accuracyArima$results[,2],3),\n                                         round(accuracyEts$results[,2],3),\n                                         round(accuracyNaive$results[,2],3),\n                                         round(accuracyNeural$results[,2],3),\n                                         round(accuracyBats$results[,2],3),\n                                         round(accuracyTbats$results[,2],3),\n                                         round(accuracyStlm$results[,2],3),\n                                         round(accuracySts$results[,2],3)))\n\n    modelNames <- as.vector(c(\"Arima\", \"ETS\", \"Naive\", \"Neural\", \"BATS\", \"TBATS\", \"STLM\", \"STS\"))\n    accuracyTbl <- data.frame(modelNames, accuracyTbl)\n    colnames(accuracyTbl) <- c(\"Model\", \"ME\", \"RMSE\", \"MAE\", \"MPE\", \"MAPE\", \"MASE\", \"ACF1\", \"THEILS\")\n    accuracyTbl\n    \n  }, ignoreNULL = FALSE)\n  \n  \n  \n  # Plot Arima model prediction \n  output$arima <- renderPlot({\n    \n    withProgress(message = \"Preparing Arima Forecast\", {\n    \n      p <- getArimaPlotData()\n      plot(p$prediction, include = p$include, ylim=c(0,as.numeric(p$maximum)))\n      lines(p$test, col = \"red\")\n      legend(\"bottomright\",\n             inset=.05,\n             cex = 1,\n             title=\"Legend\",\n             c(\"Actual Values\",\"Predicted Values\"),\n             horiz=FALSE,\n             lty=c(1,1),\n             lwd=c(2,2),\n             col=c(\"red\",\"blue\"),\n             bg=\"white\",\n             text.font=3)\n    })\n  })\n  \n  # Plot ETS forecast\n  output$ets <- renderPlot({\n    \n    withProgress(message = \"Preparing ETS Forecast\", {\n      \n      p <- getEtsPlotData()\n      plot(p$prediction, include = p$include, ylim=c(0,as.numeric(p$maximum)))\n      lines(p$test, col = \"red\")\n      legend(\"bottomright\",\n             inset=.05,\n             cex = 1,\n             title=\"Legend\",\n             c(\"Actual Values\",\"Predicted Values\"),\n             horiz=FALSE,\n             lty=c(1,1),\n             lwd=c(2,2),\n             col=c(\"red\",\"blue\"),\n             bg=\"white\",\n             text.font=3)\n    })\n  })\n  \n  # Preparing NAIVE forecast plot\n  output$naive <- renderPlot({\n    \n    withProgress(message = \"Preparing Naive Forecast\", {\n      \n      p <- getNaivePlotData()\n      plot(p$prediction, include = p$include, ylim=c(0,as.numeric(p$maximum)))\n      lines(p$test, col = \"red\")\n      legend(\"bottomright\",\n             inset=.05,\n             cex = 1,\n             title=\"Legend\",\n             c(\"Actual Values\",\"Predicted Values\"),\n             horiz=FALSE,\n             lty=c(1,1),\n             lwd=c(2,2),\n             col=c(\"red\",\"blue\"),\n             bg=\"white\",\n             text.font=3)\n    })\n  })\n\n  # Preparing Neural Forecast Plot\n  output$neural <- renderPlot({\n    \n    withProgress(message = \"Preparing Neural Forecast\", {\n      \n      p <- getNeuralPlotData()\n      plot(p$prediction, include = p$include, ylim=c(0,as.numeric(p$maximum)))\n      lines(p$test, col = \"red\")\n      legend(\"bottomright\",\n             inset=.05,\n             cex = 1,\n             title=\"Legend\",\n             c(\"Actual Values\",\"Predicted Values\"),\n             horiz=FALSE,\n             lty=c(1,1),\n             lwd=c(2,2),\n             col=c(\"red\",\"blue\"),\n             bg=\"white\",\n             text.font=3)\n    })\n  })\n  \n  # Preparing TBATS forecast plot\n  output$bats <- renderPlot({\n    \n    withProgress(message = \"Preparing BATS Forecast\", {\n      \n      p <- getBATSPlotData()\n      plot(p$prediction, include = p$include, ylim=c(0,as.numeric(p$maximum)))\n      lines(p$test, col = \"red\")\n      legend(\"bottomright\",\n             inset=.05,\n             cex = 1,\n             title=\"Legend\",\n             c(\"Actual Values\",\"Predicted Values\"),\n             horiz=FALSE,\n             lty=c(1,1),\n             lwd=c(2,2),\n             col=c(\"red\",\"blue\"),\n             bg=\"white\",\n             text.font=3)\n    })\n  })\n  \n  \n  # Preparing TBATS forecast plot\n  output$tbats <- renderPlot({\n    \n    withProgress(message = \"Preparing TBATS Forecast\", {\n      \n      p <- getTBATSPlotData()\n      plot(p$prediction, include = p$include, ylim=c(0,as.numeric(p$maximum)))\n      lines(p$test, col = \"red\")\n      legend(\"bottomright\",\n             inset=.05,\n             cex = 1,\n             title=\"Legend\",\n             c(\"Actual Values\",\"Predicted Values\"),\n             horiz=FALSE,\n             lty=c(1,1),\n             lwd=c(2,2),\n             col=c(\"red\",\"blue\"),\n             bg=\"white\",\n             text.font=3)\n    })\n  })\n  \n  \n  # Preparing STLM forecast plot\n  output$stlm <- renderPlot({\n    \n    withProgress(message = \"Preparing STLM Forecast\", {\n      \n      p <- getSTLMPlotData()\n      plot(p$prediction, include = p$include, ylim=c(0,as.numeric(p$maximum)))\n      lines(p$test, col = \"red\")\n      legend(\"bottomright\",\n             inset=.05,\n             cex = 1,\n             title=\"Legend\",\n             c(\"Actual Values\",\"Predicted Values\"),\n             horiz=FALSE,\n             lty=c(1,1),\n             lwd=c(2,2),\n             col=c(\"red\",\"blue\"),\n             bg=\"white\",\n             text.font=3)\n    })\n  })\n  \n  \n  # Prepare STS Forecast Plot\n  output$sts <- renderPlot({\n    \n    withProgress(message = \"Preparing STS Forecast\", {\n      \n      p <- getSTSPlotData()\n      plot(p$prediction, include = p$include, ylim=c(0,as.numeric(p$maximum)))\n      lines(p$test, col = \"red\")\n      legend(\"bottomright\",\n             inset=.05,\n             cex = 1,\n             title=\"Legend\",\n             c(\"Actual Values\",\"Predicted Values\"),\n             horiz=FALSE,\n             lty=c(1,1),\n             lwd=c(2,2),\n             col=c(\"red\",\"blue\"),\n             bg=\"white\",\n             text.font=3)\n    })\n  })\n  \n  # Render Performance Model Error Statistics Barchart\n  output$measurementsBar <- renderChart({\n    \n    e <- errorStats()\n    \n    p <- switch (input$measurements,\n      ME = nPlot(ME~Model, data = e, type = \"discreteBarChart\", dom = \"measurementsBar\", height = 400, width = 550),\n      RMSE = nPlot(RMSE~Model, data = e, type = \"discreteBarChart\", dom = \"measurementsBar\", height = 400, width = 550),\n      MAE = nPlot(MAE~Model, data = e, type = \"discreteBarChart\", dom = \"measurementsBar\", height = 400, width = 550),\n      MPE = nPlot(MPE~Model, data = e, type = \"discreteBarChart\", dom = \"measurementsBar\", height = 400, width = 550),\n      MAPE = nPlot(MAPE~Model, data = e, type = \"discreteBarChart\", dom = \"measurementsBar\", height = 400, width = 550),\n      MASE = nPlot(MASE~Model, data = e, type = \"discreteBarChart\", dom = \"measurementsBar\", height = 400, width = 550),\n      ACF1 = nPlot(ACF1~Model, data = e, type = \"discreteBarChart\", dom = \"measurementsBar\", height = 400, width = 550),\n      THEILS = nPlot(THEILS~Model, data = e, type = \"discreteBarChart\", dom = \"measurementsBar\", height = 400, width = 550)\n    )\n    p$xAxis(staggerLabels = TRUE)\n    p$yAxis(axisLabel = \"Error Rate\", width = 65)\n    return(p)\n  })\n  \n  \n  #Summary Table\n  output$modelsumm <- renderDataTable({\n    \n    validate(\n      need(input$state != \"\", \"Please select a market using the geographic selectors in the sidebar. \")\n    )\n    \n    e <- errorStats()\n\n    e <- rename(e, c(\"THEILS\" = \"Theil's U\"))  \n    e\n\n  })\n  \n  #===============================================================================\n  #                         MARKET FORECAST FUNCTIONS                            #\n  #===============================================================================\n  #Calculate Arima Forecast\n  arimaForecastData <- reactive({\n    \n    isolate({\n      periods <- as.integer(input$forecastRange) * 12\n    })\n      \n    #Get data and convert to timeseries\n    d  <- selectHistoricalData()\n    v  <- as.numeric(as.vector(d))\n    d  <- ts(v, frequency = 12, start = c(2000,1))\n    m  <- auto.arima(d, ic='aicc', stepwise=FALSE)\n    f  <- forecast(m, periods)\n\n  })\n  \n  #Render Arima forecast\n  output$arimaForecastPlot <- renderPlot({\n    \n    input$forecast\n    \n    withProgress(message = \"Preparing Arima Forecast\", {\n      \n      d <- isolate(arimaForecastData())\n      \n      plot.forecast(d, include = 36)\n        \n    })\n  })\n\n  \n  #Calculate ETS Forecast\n  etsForecastData <- reactive({\n    \n    isolate({\n      periods <- as.integer(input$forecastRange) * 12\n    })\n    \n    #Get data and convert to timeseries\n    d  <- selectHistoricalData()\n    v  <- as.numeric(as.vector(d))\n    d  <- ts(v, frequency = 12, start = c(2000,1))\n    m  <- ets(d, ic='aicc', restrict=FALSE)\n    f  <- forecast(m, periods)\n    \n  })\n  \n  \n  # Render ETS Forecast\n  output$etsForecastPlot <- renderPlot({\n    \n    input$forecast\n    \n    withProgress(message = \"Preparing ETS Forecast\", {\n      \n      d <- isolate(etsForecastData())\n      \n      plot.forecast(d, include = 36)\n      \n    })\n  })\n  \n  \n  #Calculate Naive Forecast\n  naiveForecastData <- reactive({\n    \n    isolate({\n      periods <- as.integer(input$forecastRange) * 12\n    })\n    \n    #Get data and convert to timeseries\n    d  <- selectHistoricalData()\n    v  <- as.numeric(as.vector(d))\n    d  <- ts(v, frequency = 12, start = c(2000,1))\n    m  <- naive(d, periods)\n    f  <- forecast(m, periods)\n    \n  })\n  \n  # Render Naive Forecast\n  output$naiveForecastPlot <- renderPlot({\n    \n    input$forecast\n    \n    withProgress(message = \"Preparing Naive Forecast\", {\n      \n      d <- isolate(naiveForecastData())\n      \n      plot.forecast(d, include = 36)      \n      \n    })\n  })\n  \n  \n  #Calculate Neural Network  Forecast\n  neuralForecastData <- reactive({\n    \n    isolate({\n      periods <- as.integer(input$forecastRange) * 12\n    })\n    \n    #Get data and convert to timeseries\n    d  <- selectHistoricalData()\n    v  <- as.numeric(as.vector(d))\n    d  <- ts(v, frequency = 12, start = c(2000,1))\n    m  <- nnetar(d, p=12, size=25)\n    f  <- forecast(m, periods)\n    \n  })\n  \n  \n  # Render Neural Network  Forecast\n  output$neuralForecastPlot <- renderPlot({\n    \n    input$forecast\n    \n    withProgress(message = \"Preparing Neural Forecast\", {\n\n      d <- isolate(neuralForecastData())\n      \n      plot.forecast(d, include = 36)      \n      \n\n    })\n  })\n  \n  \n  #Calculate BATS Network  Forecast\n  batsForecastData <- reactive({\n    \n    isolate({\n      periods <- as.integer(input$forecastRange) * 12\n    })\n    \n    #Get data and convert to timeseries\n    d  <- selectHistoricalData()\n    v  <- as.numeric(as.vector(d))\n    d  <- ts(v, frequency = 12, start = c(2000,1))\n    m  <- bats(d, ic='aicc', seasonal.periods=12)\n    f  <- forecast(m, periods)\n    \n  })\n  \n  # Render BATS Forecast\n  output$batsForecastPlot <- renderPlot({\n    \n    input$forecast\n    \n    withProgress(message = \"Preparing BATS Forecast\", {\n      \n      d <- isolate(batsForecastData())\n      \n      plot.forecast(d, include = 36)      \n      \n      \n    })\n  })\n\n  \n  #Calculate TBATS Network  Forecast\n  tbatsForecastData <- reactive({\n    \n    isolate({\n      periods <- as.integer(input$forecastRange) * 12\n    })\n    \n    #Get data and convert to timeseries\n    d  <- selectHistoricalData()\n    v  <- as.numeric(as.vector(d))\n    d  <- ts(v, frequency = 12, start = c(2000,1))\n    m  <- tbats(d, ic='aicc', seasonal.periods=12)\n    f  <- forecast(m, periods)\n    \n  })\n  \n  # Render TBATS Forecast\n  output$tbatsForecastPlot <- renderPlot({\n    \n    input$forecast\n    \n    withProgress(message = \"Preparing TBATS Forecast\", {\n      \n      d <- isolate(tbatsForecastData())\n      \n      plot.forecast(d, include = 36)      \n      \n    })\n  })\n  \n  \n  #Calculate STLM Network  Forecast\n  stlmForecastData <- reactive({\n    \n    isolate({\n      periods <- as.integer(input$forecastRange) * 12\n    })\n    \n    #Get data and convert to timeseries\n    d  <- selectHistoricalData()\n    v  <- as.numeric(as.vector(d))\n    d  <- ts(v, frequency = 12, start = c(2000,1))\n    m  <- stlm(d, s.window=12, ic='aicc', robust=TRUE, method='ets')\n    f  <- forecast(m, periods)\n    \n  })\n  \n  # Render STLM  Forecast\n  output$stlmForecastPlot <- renderPlot({\n    \n    input$forecast\n    \n    withProgress(message = \"Preparing STLM Forecast\", {\n      \n      d <- isolate(stlmForecastData())\n      \n      plot.forecast(d, include = 36)      \n      \n    })\n  })\n  \n  \n  #Calculate STLM Network  Forecast\n  stsForecastData <- reactive({\n\n    isolate({\n      periods <- as.integer(input$forecastRange) * 12\n    })\n    \n    #Get data and convert to timeseries\n    d  <- selectHistoricalData()\n    v  <- as.numeric(as.vector(d))\n    d  <- ts(v, frequency = 12, start = c(2000,1))\n    m  <- StructTS(d, type = \"level\")\n    f  <- forecast(m, periods)\n    \n  })\n  \n  # Render STS Forecast\n  output$stsForecastPlot <- renderPlot({\n    \n    input$forecast\n    \n    withProgress(message = \"Preparing STS Forecast\", {\n      \n      d <- isolate(stsForecastData())\n      \n      plot.forecast(d, include = 36)      \n      \n    })\n  })\n  \n  #Combine all model forecasts into a list\n  getForecasts <- reactive({\n    \n    withProgress(message = \"Summarizing Forecast Results\", {\n    \n      ARIMA   <-   arimaForecastData()\n      ETS     <-   etsForecastData()\n      NAIVE   <-   naiveForecastData()\n      NEURAL  <-   neuralForecastData()\n      BATS    <-   batsForecastData()\n      TBATS   <-   tbatsForecastData()\n      STLM    <-   stlmForecastData()\n      STS     <-   stsForecastData()\n      \n      \n      l <- list(ARIMA, ETS, NAIVE, NEURAL, BATS, TBATS, STLM, STS)\n    })\n    \n    return(l)\n    \n  })\n  \n  #Forecast Summary Plot\n  output$forecastSummaryPlot <- renderChart({\n\n    input$forecast\n    \n    f <- isolate(getForecasts())\n      \n    # Get time series\n    ARIMA   <-   f[[1]]\n    ETS     <-   f[[2]]\n    NAIVE   <-   f[[3]]\n    NEURAL  <-   f[[4]]\n    BATS    <-   f[[5]]\n    TBATS   <-   f[[6]]\n    STLM    <-   f[[7]]\n    STS     <-   f[[8]]\n    \n    # Convert time series to numeric vector\n    ARIMA   <-   as.numeric(ARIMA$mean)\n    ETS     <-   as.numeric(ETS$mean)\n    NAIVE   <-   as.numeric(NAIVE$mean)\n    NEURAL  <-   as.numeric(NEURAL$mean)\n    BATS    <-   as.numeric(BATS$mean)\n    TBATS   <-   as.numeric(TBATS$mean)\n    STLM    <-   as.numeric(STLM$mean)\n    STS     <-   as.numeric(STS$mean)\n    \n    # Create time vector\n    timePeriod  <- seq.Date(as.Date('2016/1/1'), by = \"month\", length.out = input$forecastRange * 12) \n    \n    # Format Time Series Data Frame\n    forecasts <- data.frame(\"Time\" = timePeriod, ARIMA,\tETS,\tNAIVE,\tNEURAL,\tBATS,\tTBATS,\tSTLM,\tSTS)\n    forecasts <- melt(forecasts, id = \"Time\")\n    names(forecasts) <- c(\"Time\", \"Model\", \"Value\")\n\n    # Render Plot\n    p <- nPlot(Value ~ Time, group = \"Model\", type = \"lineChart\", data = forecasts, dom = \"forecastSummaryPlot\")\n    p$xAxis(\n      tickFormat = \n        \"#!\n      function(d){\n      f =  d3.time.format.utc('%Y-%m-%d');\n      return f(new Date( d*24*60*60*1000 ));\n      }\n      !#\"\n    )\n    p$params$width <- 980\n    p$params$height <- 400\n    p$yAxis(tickFormat = \"#! function(d) {return d3.format(',.0f')(d)} !#\")\n    return(p)\n  })\n  \n  predictionData <- reactive({\n    \n    input$forecast\n    \n    f <- isolate(getForecasts())\n    \n    ARIMA   <-   f[[1]]\n    ETS     <-   f[[2]]\n    NAIVE   <-   f[[3]]\n    NEURAL  <-   f[[4]]\n    BATS    <-   f[[5]]\n    TBATS   <-   f[[6]]\n    STLM    <-   f[[7]]\n    STS     <-   f[[8]]\n    \n    \n    prediction_ARIMA\t<-\tas.vector(as.numeric(ARIMA$mean[length(ARIMA$mean)]))\n    prediction_ETS\t<-\tas.vector(as.numeric(ETS$mean[length(ETS$mean)]))\n    prediction_NAIVE\t<-\tas.vector(as.numeric(NAIVE$mean[length(NAIVE$mean)]))\n    prediction_NEURAL\t<-\tas.vector(as.numeric(NEURAL$mean[length(NEURAL$mean)]))\n    prediction_BATS\t<-\tas.vector(as.numeric(BATS$mean[length(BATS$mean)]))\n    prediction_TBATS\t<-\tas.vector(as.numeric(TBATS$mean[length(TBATS$mean)]))\n    prediction_STLM\t<-\tas.vector(as.numeric(STLM$mean[length(STLM$mean)]))\n    prediction_STS\t<-\tas.vector(as.numeric(STS$mean[length(STS$mean)]))\n    \n    prediction <-\tas.vector(c( prediction_ARIMA , prediction_ETS , prediction_NAIVE , prediction_NEURAL , prediction_BATS , prediction_TBATS , prediction_STLM , prediction_STS ))\n    \n    models <- c(\"Arima\", \"ETS\", \"Naive\", \"Neural\", \"BATS\", \"TBATS\", \"STLM\", \"STS\")\n    \n    d <- data.frame(models, prediction)\n    \n    colnames(d) <- c(\"Model\",\"Prediction\")\n\n    return(d)\n    \n  })\n  \n  #Prediction Summary Chart\n  output$predictionPlot <- renderChart({\n\n    input$forecast\n    \n      \n    d <- predictionData()\n    p <- nPlot(Prediction~Model, data = d, type = \"discreteBarChart\", dom = \"predictionPlot\", height = 400, width = 400)\n    p$set(title = \"Predicted Median Home Values at End of Forecast Period\")\n    p$xAxis(staggerLabels = TRUE)\n    return(p)\n })\n  \n  #Render Minimum prediction box\n  output$minPredictionBox <- renderValueBox({\n    \n    input$forecast\n    \n    d <- isolate(predictionData())\n    l <- isolate(selectCurrentData()$location)\n\n    validate(\n      need(!is.null(d),\"\")\n    )\n      \n    valueBox(\n      paste0(\"$\", round(min(d$Prediction),0)), paste(\"Minimum median home value prediction at end of forecast period for the \", l,\" market.\"), \n             icon = icon(\"dollar\"), color = \"red\")\n  })\n  \n  #Render Maxium prediction box\n  output$maxPredictionBox <- renderValueBox({\n    \n    input$forecast\n    \n    d <- isolate(predictionData())\n    l <- isolate(selectCurrentData()$location)\n    \n    validate(\n      need(!is.null(d),\"\")\n    )\n    \n    valueBox(\n      paste0(\"$\", round(max(d$Prediction),0)), paste(\"Maximum median home value prediction at end of forecast period for the \", l,\" market.\"), \n      icon = icon(\"dollar\"), color = \"orange\")\n  })\n  \n  #Render Maxium prediction box\n  output$meanPredictionBox <- renderValueBox({\n    \n    input$forecast\n    \n    d <- isolate(predictionData())\n    l <- isolate(selectCurrentData()$location)\n    \n    validate(\n      need(!is.null(d),\"\")\n    )\n    \n    valueBox(\n      paste0(\"$\", round(mean(d$Prediction),0)), paste(\"Mean median home value prediction at end of forecast period for the \", l,\" market.\"), \n      icon = icon(\"dollar\"), color = \"blue\")\n  })\n})",
    "created" : 1475189229829.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1447943053",
    "id" : "4B8BA206",
    "lastKnownWriteTime" : 1475203812,
    "path" : "C:/Users/apanwar4/Desktop/LangViz/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}